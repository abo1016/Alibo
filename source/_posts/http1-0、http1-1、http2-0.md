---
title: http1.0、http1.1、http2.0
tags: []
id: '433'
categories:
  - - all-blog
    - 网络
date: 2019-05-08 14:36:47
---

**一、汇总对比**

HTTP1.0

无状态、无连接

HTTP1.1

持久连接  
请求管道化  
增加缓存处理（新的字段如cache-control）  
增加Host字段、支持断点传输等（把文件分成几部分

HTTP2.0

二进制分帧  
多路复用（或连接共享）  
头部压缩  
服务器推送

**二、HTTP1.0：** 浏览器的每次请求都需要与服务器建立一个`TCP`连接，服务器处理完成后立即断开`TCP`连接（无连接），服务器不跟踪每个客户端也不记录过去的请求（无状态）。 **三、HTTP1.1：** HTTP/1.0中默认使用Connection: close。在HTTP/1.1中已经默认使用Connection: keep-alive，避免了连接建立和释放的开销，但服务器必须按照客户端请求的先后顺序依次回送相应的结果，以保证客户端能够区分出每次请求的响应内容。通过`Content-Length`字段来判断当前请求的数据是否已经全部接收。不允许同时存在两个**并行的响应**。 **四、HTTP2.0：** `HTTP/2`引入`二进制数据帧`和`流`的概念，其中帧对数据进行顺序标识，如下图所示，这样浏览器收到数据之后，就可以按照序列对数据进行合并，而不会出现合并后数据错乱的情况。同样是因为有了序列，服务器就可以并行的传输数据，这就是`流`所做的事情。

流（`stream`）

已建立连接上的双向字节流

消息

与逻辑消息对应的完整的一系列数据帧

帧

`HTTP2.0`通信的最小单位，每个帧包含帧头部，至少也会标识出当前帧所属的流（`stream id`）。

**多路复用**： 1、所有的`HTTP2.0`通信都在一个`TCP`连接上完成，这个连接可以承载任意数量的双向数据流。 2、每个数据流以消息的形式发送，而消息由一或多个帧组成。这些帧可以乱序发送，然后再根据每个帧头部的流标识符（`stream id`）重新组装。 举个例子，每个请求是一个数据流，数据流以消息的方式发送，而消息又分为多个帧，帧头部记录着`stream id`用来标识所属的数据流，不同属的帧可以在连接中随机混杂在一起。接收方可以根据`stream id`将帧再归属到各自不同的请求当中去。 3、另外，多路复用（连接共享）可能会导致关键请求被阻塞。`HTTP2.0`里每个数据流都可以设置优先级和依赖，优先级高的数据流会被服务器优先处理和返回给客户端，数据流还可以依赖其他的子数据流。 4、可见，`HTTP2.0`实现了真正的并行传输，它能够在一个`TCP`上进行任意数量`HTTP`请求。而这个强大的功能则是基于“二进制分帧”的特性。 **头部压缩** 在`HTTP1.x`中，头部元数据都是以纯文本的形式发送的，通常会给每个请求增加500~800字节的负荷。 `HTTP2.0`使用`encoder`来减少需要传输的`header`大小，通讯双方各自`cache`一份`header fields`表，既避免了重复`header`的传输，又减小了需要传输的大小。高效的压缩算法可以很大的压缩`header`，减少发送包的数量从而降低延迟。 **服务器推送**： 服务器除了对最初请求的响应外，服务器还可以额外的向客户端推送资源，而无需客户端明确的请求。